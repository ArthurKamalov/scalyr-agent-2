#!/usr/bin/env python
import re

__author__ = 'czerwin'

import sys

from optparse import OptionParser

from scalyr_agent.__scalyr__ import scalyr_init

scalyr_init()

from scalyr_agent.monitors_manager import load_monitor_class

__monitors__ = []

__monitors__.append(['mysql',
"""|||# ``module``               ||| Always ``scalyr_agent.builtin_monitors.shell_monitor``
|||# ``id``                   ||| Included in each log message generated by this monitor, as a field named ``instance``. \\
                                  Allows you to distinguish between values recorded by different monitors.
|||# ``command``              ||| The shell command to execute.
|||# ``extract``              ||| Optional: a regular expression to apply to the command output. If defined, this \\
                                  expression must contain a matching group (i.e. a subexpression enclosed in parentheses). \\
                                  The monitor will record only the content of that matching group. This allows you to discard \\
                                  unnecessary portions of the command output and extract the information you need.
|||# ``log_all_lines``        ||| Optional (defaults to false). If true, the monitor will record the entire command output; \\
                                  otherwise, it only records the first line.
|||# ``max_characters``       ||| Optional (defaults to 200). At most this many characters of output are recorded. \\
                                  You may specify a value up to 10000, but the Scalyr server currently truncates all \\
                                  fields to 3500 characters.""",
"""||| ``proc.stat.cpu``                   ||| ``type``  ||| CPU counters in units of jiffies, where ``type`` can be one \\
                                                          of ``user``, ``nice``, ``system``,  ``iowait``, ``irq``, \\
                                                          ``softirq``, ``steal``, ``guest``.  As a rate, they should \\
                                                           add up to  ``100*numcpus`` on the host.
||| ``proc.loadavg.1m``                 |||           ||| The load average over 1 minute.
||| ``proc.loadavg.5m``                 |||           ||| The load average over 5 minutes.
||| ``proc.loadavg.15m``                |||           ||| The load average over 15 minutes.
||| ``proc.uptime.total``               |||           ||| The total number of seconds since boot.
||| ``proc.meminfo.memtotal``           |||           ||| The total number of 1 KB pages of RAM.
||| ``proc.meminfo.memfree``            |||           ||| The total number of unused 1 KB pages of RAM. This does not \\
                                                          include the number of cached pages which can be used when \\
                                                          allocating memory.
||| ``proc.meminfo.cached``             |||           ||| The total number of 1 KB pages of RAM being used to cache \\
                                                          blocks from the filesystem.  These can be reclaimed as used \\
                                                          to allocate memory as needed.
||| ``proc.meminfo.buffered``           |||           ||| The total number of 1 KB pages of RAM being used in system \\
                                                          buffers.
||| ``proc.vmstat.pgfault``             |||           ||| The total number of minor page faults since boot.
||| ``proc.vmstat.pgmajfault``          |||           ||| The total number of major page faults since boot.
||| ``net.sockstat.num_sockets``        |||           ||| The total number of sockets allocated (only TCP) since boot.
|||  ``net.sockstat.num_timewait``      |||           ||| The total number of TCP sockets currently in TIME_WAIT state.
|||  ``net.sockstat.sockets_inuse``     ||| ``type``  ||| The total number of sockets in use by socket type.
||| ``net.stat.tcp.abort``              ||| ``type``  ||| The total number of connections that the kernel had to abort\\
                                                          broken down by reason.
||| ``iostat.disk.read_requests``       ||| ``dev``   ||| The total number of reads completed by device.
||| ``iostat.disk.msec_read``           ||| ``dev``   ||| The total time in milliseconds spent reading by device.
||| ``iostat.disk.write_requests``      ||| ``dev``   ||| The total number of writes completed by device.
||| ``iostat.disk.msec_write``          ||| ``dev``   ||| The total time in milliseconds spent writing by device.
||| ``iostat.disk.ios_in_progress``     ||| ``dev``   ||| The total number of I/O operations in progress by device.
||| ``iostat.disk.msec_total``          ||| ``dev``   ||| The total time in milliseconds doing I/O by device.
||| ``iostat.disk.msec_weighted_total`` ||| ``dev``   ||| Weighted time doing I/O (multiplied by ios_in_progress) by \\
                                                          device.
||| ``df.1kblocks.total``               ||| ``mount``, \\
                                            ``fstype``||| The total size of the file system broken down by mount and \\
                                                          filesystem type, in units of 1KB blocks.
||| ``df.1kblocks.used``                ||| ``mount``, \\
                                            ``fstype``||| The total number of used 1KB blocks on the file system broken\\
                                                          down by mount and filesystem type.
||| ``df.1kblocks.available``           ||| ``mount``, \\
                                            ``fstype``||| The total number of availabled 1KB blocks on the file system \\
                                                          broken down by mount and filesystem type.
||| ``proc.net.bytes``                  ||| ``iface``, \\
                                            ``direction`` ||| The total number of bytes transmitted through the interface \\
                                                              broken down by interface and direction.
||| ``proc.net.packets``                ||| ``iface``, \\
                                            ``direction`` ||| The total number of packets transmitted through the interface \\
                                                              broken down by interface and direction.
||| ``proc.net.errs``                   ||| ``iface``, \\
                                            ``direction`` ||| The total number of packet errors broken down by \\
                                                              interface and direction.
||| ``proc.net.dropped``                ||| ``iface``, \\
                                            ``direction`` ||| The total number of dropped packet broken down by \\
                                                              interface and direction."""])


def do_back_convert(module_name, config_section, metric_section):
    print 'Output for %s' % module_name

    lines = break_by_lines(config_section)
    for line in lines:
        fields = re.split('\|\|\|', line)
        config_field = extra_text(fields[1])
        config_description = fields[2]
        print 'define_config_option(__monitor__, \'%s\',' % config_field
        sys.stdout.write('                     \'')
        indent_length = len('define_config_option(')
        write_wrapped_line(config_description, 120 - indent_length, '%s\'' % space_filler(indent_length))
        print '\')'

    lines = break_by_lines(metric_section)
    for line in lines:
        fields = re.split('\|\|\|', line)
        metric_name = extra_text(fields[1])
        metric_description = fields[3]
        extra_fields = {}
        if len(fields[2].strip()) > 0:
            for extra in re.split(',', fields[2]):
                extra_fields[extra_text(extra)] = ''

        print 'define_metric(__monitor__, \'%s\',' % metric_name
        sys.stdout.write('              \'')
        indent_length = len('define_metric(')
        write_wrapped_line(metric_description, 120 - indent_length, '%s\'' % space_filler(indent_length))
        sys.stdout.write('\'')
        if len(extra_fields) > 0:
            sys.stdout.write(',\n%sextra_fields={\'' % space_filler(indent_length))
            sys.stdout.write('\':\'\', \''.join(extra_fields.iterkeys()))
            sys.stdout.write('\':\'\'}')
        print ')'

def write_wrapped_line(content, wrap_length, line_prefix):
    """Writes content to stdout but breaking it after ``wrap_length`` along space boundaries.

    When it begins a new line, ``line_prefix`` is printed first.

    @param content: The line to write
    @param wrap_length: The maximum size of any line emitted.  After this length, the line will be wrapped.
    @param line_prefix: The prefix to write whenenver starting a new line

    @type content: str
    @type wrap_length: int
    @type line_prefix: str
    """
    current_line = ''
    for word in content.split(' '):
        if len(current_line) + len(word) + 3 > wrap_length:
            sys.stdout.write(current_line)
            sys.stdout.write(' \'\n')
            sys.stdout.write(line_prefix)
            current_line = word
        elif len(current_line) == 0:
            current_line = word
        else:
            current_line = '%s %s' % (current_line, word)

    if len(current_line) > 0:
        sys.stdout.write(current_line)


def space_filler(num_spaces):
    """Returns a string with the specified number of spaces.

    @param num_spaces: The number of spaces
    @type num_spaces: int
    @return: The string
    @rtype: str
    """
    return ' ' * num_spaces


def extra_text(input_str):
    return re.split('``', input_str)[1]

def break_by_lines(input):
    """

    @param input:
    @type input: str
    @return:
    @rtype:
    """
    result = []

    add_previous = False
    for line in input.split('\n'):
        ends_in_cont = line.endswith('\\')
        if ends_in_cont:
            line = line[0:-2].rstrip()
        if add_previous:
            result[-1] = '%s %s' % (result[-1], line.strip())
        else:
            result.append(line)
        add_previous = ends_in_cont

    return result


if __name__ == '__main__':
    for entry in __monitors__:
        do_back_convert(entry[0], entry[1], entry[2])